// *  TMS6670L GEL File
// *
// *  This is the GEL file for use in Code Composer Studio for the 6670L platform.
// *
// *  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
// * 
// *  Redistribution and use in source and binary forms, with or without 
// *  modification, are permitted provided that the following conditions 
// *  are met:
// *
// *    Redistributions of source code must retain the above copyright 
// *    notice, this list of conditions and the following disclaimer.
// *
// *    Redistributions in binary form must reproduce the above copyright
// *    notice, this list of conditions and the following disclaimer in the 
// *    documentation and/or other materials provided with the   
// *    distribution.
// *
// *    Neither the name of Texas Instruments Incorporated nor the names of
// *    its contributors may be used to endorse or promote products derived
// *    from this software without specific prior written permission.
// *
// *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// *  KeyStone1 Emupack version "1.0.5.1"

#define GEL_VERSION     2.004

// Enable for when Manually using CCS and AVV Framework style memory map
#define SYSTEM_RESET_BEFORE_FILE_LOAD_ENABLE (0)
#define ON_RESET_CODE_ENABLE         (1)
#define ON_TARGET_CONNECT_CODE_ENABLE      (1)
#define ON_FILE_LOAD_CODE_ENABLE       (1)
#define AVV_MEM_MAP                (0)


// The System PLL governs the device (CorePac) operating speed.  
//
// Each board designer defines the CLKIN frequency.  On the 
// TMDXEVM6670L,LE,LXE EVMs, the CLKIN frequency defined to 122.88 MHz.  The 
// values for PLL1_M(31) and PLL1_D(1) defined below are pre-set 
// to provide a 983MHz operating frequency on the EVMs.
//
// Other board designs using different CLKIN frequencies and/or 
// applications that requiring other operating frequecies, the PLL can 
// be configured by adjusting PLL1_M and PLL1_D per the 
// following formula:
//
//     Target Frequency (MHz) = 
//         input_clock (MHz) * [(PLL1_M + 1)]/ (2 * (PLL1_D + 1) )
//
// Table 2-13, "C66x DSP System PLL Configuration" in the device data sheet, 
// http://focus.ti.com/lit/ds/symlink/tms320c6670.pdf provides the suggested
// values for PLL1_M and PLL1_D for various input clocks and desired
// operating frequencies.
// 
// Please note that there might be multiple PLL1_M and PLL1_D
// values for the same Input clock and Desired Device Speed as long as the 
// multipliers and dividers are in the acceptable range. 
//
// More details on the PLL including the limitations on acceptable ranges
// for multipliers and dividers are in the PLL's user guide at
// http://www.ti.com/lit/sprugv2
// 
// The table provides some sample values of PLL1_M and PLL1_D:
//
// Please select PLL1_M values such that 0 < PLL1_M <= 64
// +--------------------+---------------+--------+--------+
// | (CLK)Desired       | (CLKIN) Input |        |        |
// | Device Speed (MHz) | Clock (MHz)   | PLL1_M | PLL1_D |
// +--------------------+---------------+--------+--------+
// | 1000               | 100           | 19     | 0      |
// | 1000               | 100           | 39     | 1      |
// | 1250               | 100           | 24     | 0      |
// |  983               | 122.88 (EVM)  | 31     | 1      |
// | 1000               | 156.25        | 63     | 4      |
// +--------------------+---------------+--------+--------+
//
// +--------------------+---------------+--------+--------+
// | PA PLL VCO         | (CLKIN) Input |        |        |
// | Rate (MHz)         | Clock (MHz)   | PLL1_M | PLL1_D |
// +--------------------+---------------+--------+--------+
// | 1050               | 100           | 24     | 0      |
// | 1044               | 122.88 (EVM)  | 31     | 1      |
// | 1050               | 122.88        | 204    | 11     |
// | 1050               | 156.25        | 335    | 24     |
// +--------------------+---------------+--------+--------+
//
// +--------------------+---------------+--------+--------+
// | DDR3 PLL VCO       | (CLKIN) Input |        |        |
// | Rate (MHz)         | Clock (MHz)   | PLL1_M | PLL1_D |
// +--------------------+---------------+--------+--------+
// | 1333               | 66.667 (EVM)  | 19     | 0      |
// | 1066               | 66.667        | 31     | 1      |
// | 800                | 66.667        | 11     | 0      |
// +--------------------+---------------+--------+--------+

#define PLL1_M 31
#define PLL1_D 1

#define PLLDIV1_val    3
#define PLLDIV4_val    5
#define PLLDIV7_val    64

#define DDR3_BASE_ADDRESS            0x80000000

// Global Register and constant definitions
#define REF_CLOCK_KHZ 122880

// Global timeout value
#define GTIMEOUT 2000

//*****************************************************
// Power definitions
#define PSC_BASE            0x02350000
#define PSC_PTCMD           *( unsigned int* )( PSC_BASE+0x120 )
#define PSC_PTSTAT          *( unsigned int* )( PSC_BASE+0x128 )
#define PSC_PDCTL_BASE      ( PSC_BASE+0x300 )
#define PSC_MDSTAT_BASE     ( PSC_BASE+0x800 )
#define PSC_MDCTL_BASE      ( PSC_BASE+0xA00 )

// Modules on power domain 0
#define LPSC_SMARTRFLX (1)
#define LPSC_DDR3      (2)
#define LPSC_TCP3E     (3)
#define LPSC_VCP2A     (4)

// Modules on power domain 1
#define LPSC_DEBUG     (5)
#define LPSC_TETB      (6)

// Modules on power domain 2
#define LPSC_PA        (7)
#define LPSC_SGMII     (8)
#define LPSC_SA        (9)

// Modules on power domain 3
#define LPSC_PCIE      (10)

// Modules on power domain 4
#define LPSC_SRIO      (11)

// Modules on power domain 5
#define LPSC_HYPER     (12)

// Modules on power domain 6
#define LPSC_RESERV    (13)

// Modules on power domain 7
#define LPSC_MSMCRAM   (14)

// Modules on power domain 8
#define LPSC_RACA_RACB (15)
#define LPSC_TAC       (16)

// Modules on power domain 9
#define LPSC_FFTCA_FFTCB (17)

// Modules on power domain 10
#define LPSC_AIF2      (18)

// Modules on power domain 11
#define LPSC_TCP3DA    (19)

// Modules on power domain 12
#define LPSC_VCP2B     (20)
#define LPSC_VCP2C     (21)
#define LPSC_VCP2D     (22)

// Modules on power domain 13
#define LPSC_C0_TIM0   (23)

// Modules on power domain 14
#define LPSC_C1_TIM1   (24)
#define LPSC_C1_RSA    (25)

// Modules on power domain 15
#define LPSC_C2_TIM2   (26)
#define LPSC_C2_RSA    (27)

// Modules on power domain 16
#define LPSC_C3_TIM3   (28)

// Modules on power domain 17
#define LPSC_TCP3dB    (29)

// Power domains definitions
#define PD0         (0)     // Power Domain-0
#define PD1         (1)     // Power Domain-1
#define PD2         (2)     // Power Domain-2
#define PD3         (3)     // Power Domain-3
#define PD4         (4)     // Power Domain-4
#define PD5         (5)     // Power Domain-5
#define PD6         (6)     // Power Domain-6
#define PD7         (7)     // Power Domain-7
#define PD8         (8)     // Power Domain-8
#define PD9         (9)     // Power Domain-9
#define PD10        (10)    // Power Domain-10
#define PD11        (11)    // Power Domain-11
#define PD12        (12)    // Power Domain-12
#define PD13        (13)    // Power Domain-13
#define PD14        (14)    // Power Domain-14
#define PD15        (15)    // Power Domain-15
#define PD16        (16)    // Power Domain-16
#define PD17        (17)    // Power Domain-17

#define PSC_SYNCRESET (0x1)
#define PSC_DISABLE   (0x2)
#define PSC_ENABLE    (0x3)

//*****************************************************
// BOOT and CONFIG dsp system modules Definitions
#define CHIP_LEVEL_REG  0x02620000
#define DEVSTAT                     (*(unsigned int*)(CHIP_LEVEL_REG + 0x0020))
#define KICK0                       (*(unsigned int*)(CHIP_LEVEL_REG + 0x0038))
#define KICK1                       (*(unsigned int*)(CHIP_LEVEL_REG + 0x003C))
#define TINPSEL                     (*(unsigned int*)(CHIP_LEVEL_REG + 0x0300))
#define TOUTPSEL                    (*(unsigned int*)(CHIP_LEVEL_REG + 0x0304))
#define MAINPLLCTL0                 (*(unsigned int*)(CHIP_LEVEL_REG + 0x0328))
#define MAINPLLCTL1                 (*(unsigned int*)(CHIP_LEVEL_REG + 0x032C))
#define DDR3PLLCTL0                 (*(unsigned int*)(CHIP_LEVEL_REG + 0x0330))
#define DDR3PLLCTL1                 (*(unsigned int*)(CHIP_LEVEL_REG + 0x0334))
#define PAPLLCTL0                   (*(unsigned int*)(CHIP_LEVEL_REG + 0x0338))
#define PAPLLCTL1                   (*(unsigned int*)(CHIP_LEVEL_REG + 0x033C))
#define OBSCLKCTL                   (*(unsigned int*)(CHIP_LEVEL_REG + 0x03AC))

// DDR3 tuning registers
#define DATA0_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x043C))
#define DATA1_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0440))
#define DATA2_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0444))
#define DATA3_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0448))
#define DATA4_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x044C))
#define DATA5_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0450))
#define DATA6_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0454))
#define DATA7_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0458))
#define DATA8_GTLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x045C))

#define DATA0_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x040C))
#define DATA1_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0410))
#define DATA2_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0414))
#define DATA3_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0418))
#define DATA4_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x041C))
#define DATA5_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0420))
#define DATA6_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0424))
#define DATA7_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x0428))
#define DATA8_WRLVL_INIT_RATIO      (*(unsigned int*)(CHIP_LEVEL_REG + 0x042C))

#define DDR3_CONFIG_REG_0           (*(unsigned int*)(CHIP_LEVEL_REG + 0x0404))
#define DDR3_CONFIG_REG_12          (*(unsigned int*)(CHIP_LEVEL_REG + 0x0434))
#define DDR3_CONFIG_REG_23          (*(unsigned int*)(CHIP_LEVEL_REG + 0x0460))
#define DDR3_CONFIG_REG_24          (*(unsigned int*)(CHIP_LEVEL_REG + 0x0464))

#define SGMII_SERDES_CFGPLL         (*(unsigned int*)(CHIP_LEVEL_REG + 0x340))
#define SGMII_SERDES_CFGRX0         (*(unsigned int*)(CHIP_LEVEL_REG + 0x344))
#define SGMII_SERDES_CFGTX0         (*(unsigned int*)(CHIP_LEVEL_REG + 0x348))
#define SGMII_SERDES_CFGRX1         (*(unsigned int*)(CHIP_LEVEL_REG + 0x34C))
#define SGMII_SERDES_CFGTX1         (*(unsigned int*)(CHIP_LEVEL_REG + 0x350))

#define KICK0_UNLOCK (0x83E70B13)
#define KICK1_UNLOCK (0x95A4F1E0)
#define KICK_LOCK    0


/* PA PLL Observation Clock Control Register */
#define PA_PLL_OBS_CLK_SEL_MASK (1 << 4) /* OBSCLKCTL Register Bit 4 - set to 0 to see PA PLL reference (input) clock, set to 1 to see PA PLL output*/
#define PA_PLL_OBS_CLK_EN_MASK  (1 << 5) /* OBSCLKCTL Register Bit 5 - set to 1 to enable power to PA PLL observation clock*/

/* PA PLL Registers */
#define BYPASS_BIT_SHIFT 23
#define CLKF_BIT_SHIFT   6
#define PASSCLKSEL_MASK    (1 << 17)    /* Tells the configuration of the PASSCLKSEL pin */
#define PA_PLL_BYPASS_MASK (1 << BYPASS_BIT_SHIFT)    /* Tells whether the PA PLL is in BYPASS mode or not */
#define PA_PLL_CLKOD_MASK  (0x00780000) /* Tells the output divider value for the PA PLL */
#define PA_PLL_CLKF_MASK   (0x0007FFC0) /* Tells the multiplier value for the PA PLL */
#define PA_PLL_CLKR_MASK   (0x0000003F) /* Tells the divider value for the PA PLL */

//*****************************************************
// Timeout definitions
int _GEL_Global_Timeout1 = 0;

#define TIMEOUT_ID 10

//*****************************************************
// Extended Memory Controller (XMC) Configuration
#define XMC_BASE_ADDR (0x08000000)
#define XMPAX2_L     (*(unsigned int*)(XMC_BASE_ADDR + 0x00000010))
#define XMPAX2_H     (*(unsigned int*)(XMC_BASE_ADDR + 0x00000014))

// DDR3 definitions
#define DDR_BASE_ADDR          0x21000000

#define DDR_MIDR                    (*(unsigned int*)(DDR_BASE_ADDR + 0x00000000))
#define DDR_SDCFG                   (*(unsigned int*)(DDR_BASE_ADDR + 0x00000008))
#define DDR_SDRFC                   (*(unsigned int*)(DDR_BASE_ADDR + 0x00000010))
#define DDR_SDTIM1                  (*(unsigned int*)(DDR_BASE_ADDR + 0x00000018))
#define DDR_SDTIM2                  (*(unsigned int*)(DDR_BASE_ADDR + 0x00000020))
#define DDR_SDTIM3                  (*(unsigned int*)(DDR_BASE_ADDR + 0x00000028))
#define DDR_PMCTL                   (*(unsigned int*)(DDR_BASE_ADDR + 0x00000038))
#define DDR_ZQCFG                   (*(unsigned int*)(DDR_BASE_ADDR + 0x000000C8))
#define DDR_RDWR_LVL_RMP_CTRL       (*(unsigned int*)(DDR_BASE_ADDR + 0x000000D8))
#define DDR_TMPALRT                 (*(unsigned int*)(DDR_BASE_ADDR + 0x000000CC))
#define DDR_RDWR_LVL_CTRL           (*(unsigned int*)(DDR_BASE_ADDR + 0x000000DC))
#define DDR_DDRPHYC                 (*(unsigned int*)(DDR_BASE_ADDR + 0x000000E4))

#define RD_DQS_SLAVE_RATIO_1333 0x34
#define WR_DQS_SLAVE_RATIO_1333 0x45
#define WR_DATA_SLAVE_RATIO_1333 0x85
#define FIFO_WE_SLAVE_RATIO_1333 0xBC

#define RD_DQS_SLAVE_RATIO_1066 0x34
#define WR_DQS_SLAVE_RATIO_1066 0x37
#define WR_DATA_SLAVE_RATIO_1066 0x77
#define FIFO_WE_SLAVE_RATIO_1066 0xA0


//*****************************************************

// PLL 1 definitions (DSP clk and subsystems)
#define PLL1_BASE           0x02310000
#define PLL1_PLLCTL              (*(unsigned int*)(PLL1_BASE + 0x100))   // PLL1 Control
#define PLL1_SECCTL              (*(unsigned int*)(PLL1_BASE + 0x108))   // PLL1 Sec Control
#define PLL1_PLLM                (*(unsigned int*)(PLL1_BASE + 0x110))   // PLL1 Multiplier
#define PLL1_DIV1                (*(unsigned int*)(PLL1_BASE + 0x118))   // DIV1 divider
#define PLL1_DIV2                (*(unsigned int*)(PLL1_BASE + 0x11C))   // DIV2 divider
#define PLL1_DIV3                (*(unsigned int*)(PLL1_BASE + 0x120))   // DIV3 divider
#define PLL1_CMD                 (*(unsigned int*)(PLL1_BASE + 0x138))   // CMD control
#define PLL1_STAT                (*(unsigned int*)(PLL1_BASE + 0x13C))   // STAT control
#define PLL1_ALNCTL              (*(unsigned int*)(PLL1_BASE + 0x140))   // ALNCTL control
#define PLL1_DCHANGE             (*(unsigned int*)(PLL1_BASE + 0x144))   // DCHANGE status
#define PLL1_CKEN                (*(unsigned int*)(PLL1_BASE + 0x148))   // CKEN control
#define PLL1_CKSTAT              (*(unsigned int*)(PLL1_BASE + 0x14C))   // CKSTAT status
#define PLL1_SYSTAT              (*(unsigned int*)(PLL1_BASE + 0x150))   // SYSTAT status
#define PLL1_DIV4                (*(unsigned int*)(PLL1_BASE + 0x160))   // DIV4 divider
#define PLL1_DIV5                (*(unsigned int*)(PLL1_BASE + 0x164))   // DIV5 divider
#define PLL1_DIV6                (*(unsigned int*)(PLL1_BASE + 0x168))   // DIV6 divider
#define PLL1_DIV7                (*(unsigned int*)(PLL1_BASE + 0x16C))   // DIV7 divider
#define PLL1_DIV8                (*(unsigned int*)(PLL1_BASE + 0x170))   // DIV8 divider
#define PLL1_DIV9                (*(unsigned int*)(PLL1_BASE + 0x174))   // DIV9 divider
#define PLL1_DIV10               (*(unsigned int*)(PLL1_BASE + 0x178))   // DIV10 divider
#define PLL1_DIV11               (*(unsigned int*)(PLL1_BASE + 0x17C))   // DIV11 divider
#define PLL1_DIV12               (*(unsigned int*)(PLL1_BASE + 0x180))   // DIV12 divider
#define PLL1_DIV13               (*(unsigned int*)(PLL1_BASE + 0x184))   // DIV13 divider
#define PLL1_DIV14               (*(unsigned int*)(PLL1_BASE + 0x188))   // DIV14 divider
#define PLL1_DIV15               (*(unsigned int*)(PLL1_BASE + 0x18C))   // DIV15 divider
#define PLL1_DIV16               (*(unsigned int*)(PLL1_BASE + 0x190))   // DIV16 divider

//*****************************************************
// CACHE definitions
#define CACHE_BASE          0x01840000
#define CACHE_L2CFG             (*( unsigned int* )( CACHE_BASE ))
#define CACHE_L1PCFG            (*( unsigned int* )( CACHE_BASE + 0x0020 ))
#define CACHE_L1DCFG            (*( unsigned int* )( CACHE_BASE + 0x0040 ))
#define L2WBINV                 (CACHE_BASE + 0x5004) // L2WBINV Control
#define L2INV                   (CACHE_BASE + 0x5008) // L2INV Control
#define L1PINV                  (CACHE_BASE + 0x5028) // L1PINV Control
#define L1DWBINV                (CACHE_BASE + 0x5044) // L1DWBINV Control
#define L1DINV                  (CACHE_BASE + 0x5048) // L1DINV Control

//*****************************************************
// EDMA3 definitions
#define EDMA3_TPCC0_BASE    0x02700000
#define IERH_0                (EDMA3_TPCC0_BASE + 0x1054) // IERH Control
#define EERH_0                (EDMA3_TPCC0_BASE + 0x1024) // EERH Control
#define ICRH_0                (EDMA3_TPCC0_BASE + 0x1074) // ICRH Control
#define ECRH_0                (EDMA3_TPCC0_BASE + 0x100C) // ECRH Control
#define IER_0                 (EDMA3_TPCC0_BASE + 0x1050) // IER Control
#define EER_0                 (EDMA3_TPCC0_BASE + 0x1020) // EER Control
#define ICR_0                 (EDMA3_TPCC0_BASE + 0x1070) // ICR Control
#define ECR_0                 (EDMA3_TPCC0_BASE + 0x1008) // ECR Control
#define IECRH_0               (EDMA3_TPCC0_BASE + 0x105C) // IECRH Control
#define IECR_0                (EDMA3_TPCC0_BASE + 0x1058) // IECR Control
#define EECRH_0               (EDMA3_TPCC0_BASE + 0x102C) // EECRH Control
#define EECR_0                (EDMA3_TPCC0_BASE + 0x1028) // EECR Control

#define EDMA3_TPCC1_BASE    0x02720000
#define IERH_1                (EDMA3_TPCC1_BASE + 0x1054) // IERH Control
#define EERH_1                (EDMA3_TPCC1_BASE + 0x1024) // EERH Control
#define ICRH_1                (EDMA3_TPCC1_BASE + 0x1074) // ICRH Control
#define ECRH_1                (EDMA3_TPCC1_BASE + 0x100C) // ECRH Control
#define IER_1                 (EDMA3_TPCC1_BASE + 0x1050) // IER Control
#define EER_1                 (EDMA3_TPCC1_BASE + 0x1020) // EER Control
#define ICR_1                 (EDMA3_TPCC1_BASE + 0x1070) // ICR Control
#define ECR_1                 (EDMA3_TPCC1_BASE + 0x1008) // ECR Control
#define IECRH_1               (EDMA3_TPCC1_BASE + 0x105C) // IECRH Control
#define IECR_1                (EDMA3_TPCC1_BASE + 0x1058) // IECR Control
#define EECRH_1               (EDMA3_TPCC1_BASE + 0x102C) // EECRH Control
#define EECR_1                (EDMA3_TPCC1_BASE + 0x1028) // EECR Control

#define EDMA3_TPCC2_BASE    0x02740000
#define IERH_2                (EDMA3_TPCC2_BASE + 0x1054) // IERH Control
#define EERH_2                (EDMA3_TPCC2_BASE + 0x1024) // EERH Control
#define ICRH_2                (EDMA3_TPCC2_BASE + 0x1074) // ICRH Control
#define ECRH_2                (EDMA3_TPCC2_BASE + 0x100C) // ECRH Control
#define IER_2                 (EDMA3_TPCC2_BASE + 0x1050) // IER Control
#define EER_2                 (EDMA3_TPCC2_BASE + 0x1020) // EER Control
#define ICR_2                 (EDMA3_TPCC2_BASE + 0x1070) // ICR Control
#define ECR_2                 (EDMA3_TPCC2_BASE + 0x1008) // ECR Control
#define IECRH_2               (EDMA3_TPCC2_BASE + 0x105C) // IECRH Control
#define IECR_2                (EDMA3_TPCC2_BASE + 0x1058) // IECR Control
#define EECRH_2               (EDMA3_TPCC2_BASE + 0x102C) // EECRH Control
#define EECR_2                (EDMA3_TPCC2_BASE + 0x1028) // EECR Control

//*****************************************************
// GPIO definitions
#define GPIO_BASE           0x02320000
#define GPIO_BITEN          (*(unsigned int*)(GPIO_BASE + 0x0008)) // BITEN Control
#define GPIO_DIR            (*(unsigned int*)(GPIO_BASE + 0x0010)) // DIR Control
#define GPIO_OUT_DATA       (*(unsigned int*)(GPIO_BASE + 0x0014)) // OUT_DATA Control
#define GPIO_IN_DATA        (*(unsigned int*)(GPIO_BASE + 0x0020)) // IN_DATA Register
#define GPIO_CLR_RIS_TRIG   (*(unsigned int*)(GPIO_BASE + 0x0028)) // CLR_RIS_TRIG Control
#define GPIO_CLR_FAL_TRIG   (*(unsigned int*)(GPIO_BASE + 0x0030)) // CLR_FAL_TRIG Control

#define GPIO_DEFAULT_DIR    0xFFFF2CFF  // GP08,GP09,GP12,GP14,GP15 (Nand) are outputs
#define GPIO_DEFAULT_OUT    0x0000D000  // GP15, GP14, GP12 default to HIGH

// Used for eeprom programming
#define LITTLE_END 1
#define BIG_END 2

// SGMII definitions 
#define SGMII_SERDES_BASE  0x02090000
#define SGMII_SLIVER_BASE1 0x02090900
#define SGMII_SLIVER_BASE2 0x02090940
#define SGMII_SERDES_CONTROL_PORT1      (*(unsigned int*)(SGMII_SERDES_BASE  + 0x210))
#define SGMII_SERDES_MR_ADV_PORT1       (*(unsigned int*)(SGMII_SERDES_BASE  + 0x218))
#define SGMII_SERDES_AUX_CFG_PORT1      (*(unsigned int*)(SGMII_SERDES_BASE  + 0x238))
#define SGMII_SERDES_CONTROL_PORT0      (*(unsigned int*)(SGMII_SERDES_BASE  + 0x110))
#define SGMII_SERDES_MR_ADV_PORT0       (*(unsigned int*)(SGMII_SERDES_BASE  + 0x118))
#define SGMII_SERDES_AUX_CFG_PORT0      (*(unsigned int*)(SGMII_SERDES_BASE  + 0x138))
#define SGMII_SLIVER_MACCONTROL1        (*(unsigned int*)(SGMII_SLIVER_BASE1 + 0x004))
#define SGMII_SLIVER_MAXLEN1            (*(unsigned int*)(SGMII_SLIVER_BASE1 + 0x010))
#define SGMII_SLIVER_MACCONTROL2        (*(unsigned int*)(SGMII_SLIVER_BASE2 + 0x004))
#define SGMII_SLIVER_MAXLEN2            (*(unsigned int*)(SGMII_SLIVER_BASE2 + 0x010))

#define CPSW3G_BASE             0x02090800
#define CPSW3G_CONTROL_REG              (*(unsigned int*)(CPSW3G_BASE + 0x004))
#define CPSW3G_STAT_PORT_REG            (*(unsigned int*)(CPSW3G_BASE + 0x00C))
#define CPSW3G_ALE_CONTROL_REG          (*(unsigned int*)(CPSW3G_BASE + 0x608))
#define CPSW3G_ALE_PORT_0_CTL_REG       (*(unsigned int*)(CPSW3G_BASE + 0x640))
#define CPSW3G_ALE_PORT_1_CTL_REG       (*(unsigned int*)(CPSW3G_BASE + 0x644))
#define CPSW3G_ALE_PORT_2_CTL_REG       (*(unsigned int*)(CPSW3G_BASE + 0x648))
#define CPSW3G_ALE_PORT_STATE_FORWARD   0x3


//TIMER 0 definitions
#define TIMER0_CNTLO                     (*(unsigned int*)(0x02200010))
#define TIMER0_CNTHI                     (*(unsigned int*)(0x02200014))
#define TIMER0_PRDLO                     (*(unsigned int*)(0x02200018))
#define TIMER0_PRDHI                     (*(unsigned int*)(0x0220001C))
#define TIMER0_TCR                       (*(unsigned int*)(0x02200020))
#define TIMER0_TGCR                      (*(unsigned int*)(0x02200024))

#define PLL_REINIT_MAX_COUNT (10)

/*
 * The delay function is called from wherever a delay is needed.  The parameter is the 
 * delay period (in milliseconds)
 */
Delay_milli_seconds(myDelay)
{      
    Set_Timeout(myDelay);
    while(Get_Timeout());
    Kill_Timeout();

}


/**
 *  @brief Simple DDR3 test
 *
 *  @details
 *      This function performs a simple DDR3 test for a memory range
 *      specified below and returns -1 for failure and 0 for success.
 */

#define DDR3_TEST_START_ADDRESS (0x80000000)

#define DDR3_TEST_END_ADDRESS   (DDR3_TEST_START_ADDRESS + (4 * 100))

ddr3_memory_test ()
{
    unsigned int index, value;

    GEL_TextOut( "DDR3 memory test... Started\n" );

    /* Write a pattern */
    for (index = DDR3_TEST_START_ADDRESS; index < DDR3_TEST_END_ADDRESS; index += 4) {
        *index = index;
    }

    /* Read and check the pattern */
    for (index = DDR3_TEST_START_ADDRESS; index < DDR3_TEST_END_ADDRESS; index += 4) {

        value = *index;

        if (value  != index) {
            GEL_TextOut( "DDR3 memory test... Failed\n" );
            return -1;
        }
    }

    /* Write a pattern for complementary values */
    for (index = DDR3_TEST_START_ADDRESS; index < DDR3_TEST_END_ADDRESS; index += 4) {
        *index = ~index;
    }

    /* Read and check the pattern */
    for (index = DDR3_TEST_START_ADDRESS; index < DDR3_TEST_END_ADDRESS; index += 4) {

        value = *index;

        if (value  != ~index) {
            GEL_TextOut( "DDR3 memory test... Failed\n" );
            return -1;
        }
    }

    GEL_TextOut( "DDR3 memory test... Passed\n" );
    return 0;
}

menuitem "CPSW Functions";
/****************************************************************************
 *
 * NAME
 *      configSGMIISerdes
 *
 * PURPOSE:
 *      Setup SGMII and Serdes for ethernet communications.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      configSGMIISerdes()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu configSGMIISerdes()
{

    GEL_TextOut( "configSGMIISerdes Setup... Begin\n" );


    /* Unlock Chip Level Registers */
    KICK0 = KICK0_UNLOCK;
    KICK1 = KICK1_UNLOCK;

    SGMII_SERDES_CONTROL_PORT1 = 0x0;
    SGMII_SERDES_CONTROL_PORT0 = 0x0;
    /* Multiply to be 8 with Quarter Rate in the Rx registers */
    SGMII_SERDES_CFGPLL = 0x00000051;


    /* Wait */
    Wait_Soft(100);


    //31:25    Reserved    0000000
    //23:24    LOOPBACK    00
    //   22    ENOC        1
    //21:18    EQ          0001
    //17:15    CDR         001 -- first order threshold of 17
    //14:12    LOS         000 -- tie off
    //11:10    ALIGN       01  -- Comma Aligned
    //09:07    TERM        100 -- tie off (100)
    //   06    INVPAIR     0
    //05:04    RATE        01  -- tie off (10)  //00 = Full Rate, 01 = Half Rate (*0.5), 10 = Quarter Rate (*0.25)
    //03:01    BUSWIDTH    000 -- tie off
    //   00    ENRX        1
    // 0000 0000 0100 0100 0000 0010 0001 0001 = 0x0044_0211 -- My estimated value
    // 0000 0000 0100 0100 0000 0100 0001 0001 = 0x0044_0411 -- New DV value
    // 0000 0000 0000 1000 0000 1000 0100 0001 = 0x0008_0841 -- Original DV value
    SGMII_SERDES_CFGRX0 = 0x00700621;
    SGMII_SERDES_CFGRX1 = 0x00700621;


    //31:22    Reserved    0
    //21:20    LOOPBACK    00
    //19:18    RDTCT       00  -- tie off
    //   17    ENIDL       0   -- tie off
    //   16    MYSNC       1   -- tie off
    //15:12    DEMPHASIS   ???? - 0001 Lets give some de-emphasis
    //11:08    SWING       ????
    //   07    CM          1   -- tie off
    //   06    INVPAIR     0
    //05:04    RATE        01  -- tie off
    //03:01    BUSWIDTH    000 -- tie off
    //   00    ENTX        1
    // 0000 0000 0011 0001 ???? ???? 1001 0001 = 0x0031_1E91 -- My estimated value
    // 0000 0000 0000 0001 0000 1111 0001 0001 = 0x0001_0F11 -- New DV value
    // 0000 0000 0100 0000 0001 1110 0100 0001 = 0x0040_1e41 -- Original DV value

    SGMII_SERDES_CFGTX0 = 0x000108A1;
    SGMII_SERDES_CFGTX1 = 0x000108A1;

    SGMII_SERDES_AUX_CFG_PORT0 = 0x00000041;
    SGMII_SERDES_AUX_CFG_PORT1 = 0x00000041;

    /* waitforclock() */
    Wait_Soft(1000);

    SGMII_SERDES_MR_ADV_PORT0 = 0x1;
    SGMII_SERDES_MR_ADV_PORT1 = 0x1;
    Wait_Soft(100);
    SGMII_SERDES_CONTROL_PORT1 = 0x1;
    SGMII_SERDES_CONTROL_PORT0 = 0x1;

    /*Configuring Sliver */
    SGMII_SLIVER_MAXLEN2 = 0x2520;
    SGMII_SLIVER_MAXLEN1 = 0x2520;

    SGMII_SLIVER_MACCONTROL2 = 0xA1;
    SGMII_SLIVER_MACCONTROL1 = 0xA1;


    /* Lock Chip Level Registers */
    KICK0 = KICK_LOCK;
    KICK1 = KICK_LOCK;

    GEL_TextOut("\nSGMII SERDES has been configured.\n");

}

/* Initialize switch configuration */
/****************************************************************************
 *
 * NAME
 *      setCpSwConfig
 *
 * PURPOSE:
 *      Enable the CpSw Switch and configure the ALE.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      setCpSwConfig()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/

hotmenu setCpSwConfig()
{
    /* Enable Port 0 */
    CPSW3G_CONTROL_REG = 0x4;
    CPSW3G_STAT_PORT_REG = 0xF;

    /* Enable ALE. */
    CPSW3G_ALE_CONTROL_REG = 0x80000000;
    /* Enable ALE port state to Forward */
    CPSW3G_ALE_PORT_0_CTL_REG = 0x3;
    CPSW3G_ALE_PORT_1_CTL_REG = 0x3;
    CPSW3G_ALE_PORT_2_CTL_REG = 0x3;

}

/*--------------------------------------------------------------*/
/* EVMC6670L MENU                                              */
/*--------------------------------------------------------------*/
menuitem "LC_EVM_C6670_Functions";

// Flag for i2c eeprom programming process
int i2cprog=0;

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Global_Default_Setup()
{
    GEL_TextOut( "Global Default Setup...\n" );
    Global_Default_Setup_Silent();
    GEL_TextOut( "Global Default Setup... Done.\n" );
}

/****************************************************************************
 *
 * NAME
 *      Memory_Test
 *
 * PURPOSE:
 *      Memory Test for the EVM.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Memory_Test()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Memory_Test()
{
    //int data_set[4];
    //= {0xAAAAAAAA, 0x55555555, 0xFFFFFFFF, 0x00000000};
    unsigned int write_data = 0xAAAAAAAA;
    unsigned int read_data = 0x0;
    unsigned int errors = 0;
    int dw;
    unsigned int i, mem_start, mem_size, mem_location;
    mem_start = DDR3_BASE_ADDRESS + (DNUM * 0x01000000);
    mem_size = 0x100;
    for(dw=0;dw<4;dw++)
    {
        if (dw == 0) write_data = 0xAAAAAAAA;
        if (dw == 1) write_data = 0x55555555;
        if (dw == 2) write_data = 0xFFFFFFFF;
        if (dw == 3) write_data = 0x00000000;
        mem_location = mem_start;
        GEL_TextOut( "Memory Test Write Core: %d, Mem Start: 0x%x, Mem Size: 0x%x, value: 0x%x ...\n",,2,,,DNUM,mem_start,mem_size,write_data);
        for(i=0;i<mem_size;i++)
        {
            *( unsigned int* )(mem_location) = write_data;
            mem_location += 4;
        }
        mem_location = mem_start;
        GEL_TextOut( "Memory Test Read Core: %d, Mem Start: 0x%x, Mem Size: 0x%x ...\n",,2,,,DNUM,mem_start,mem_size);
        for (i=0;i<mem_size;i++)
        {
            read_data = *( unsigned int* )(mem_location);
            if (read_data != write_data)
            {
                GEL_TextOut("DDR3 Data Error: DSP Core: %d, Mem Addr: 0x%x, read: 0x%x, expected: 0x%x \n",,2,,,DNUM,(DDR3_BASE_ADDRESS + (i * 4)),read_data,write_data);
                errors++;
            }
            mem_location += 4;
        }
        if (errors == 0)
        {
            GEL_TextOut( "Memory Test Done, no errors found.\n" );
        }
        else
        {
            GEL_TextOut("Memory Test Done, %d errors were encounterd. \n",,2,,,errors);
        }
    }
    GEL_TextOut( "All Memory Test Completed on core: %d with %d errors.\n",,2,,,DNUM,errors);
}

/****************************************************************************
 *
 * NAME
 *      Invalidate_Cache
 *
 * PURPOSE:
 *      Invalidate L1P, L1D and L2 cache (purge all cache contents).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Invalidate_Cache()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Invalidate_Cache()
{
    GEL_TextOut( "Invalidate All Cache...\n" );

    /* Invalidate L1P cache */
    *(int*)L1PINV = 1;

    // Wait for cache operation to finish
    // Set timeout before polling...
    Set_Timeout(GTIMEOUT);

    // Wait for transition to finish for max timeout time...
    while( Get_Timeout() && ( *(int*)L1PINV & 0x0001 ) );

    // Check if we got timeout error while waiting
    if (!Get_Timeout())
    {
        GEL_TextOut( "Invalidate All Cache... Timeout Error #01!\n",,2,,,);
    }

    /* Invalidate L1D cache */
    *(int*)L1DINV = 1;

    // Wait for cache operation to finish
    // Set timeout before polling...
    Set_Timeout(GTIMEOUT);

    // Wait for transition to finish for max timeout time...
    while( Get_Timeout() && ( *(int*)L1DINV & 0x0001 ) );

    // Check if we got timeout error while waiting
    if (!Get_Timeout())
    {
        GEL_TextOut( "Invalidate All Cache... Timeout Error #02!\n",,2,,,);
    }

    /* Invalidate L2 cache */
    *(int*)L2INV = 1;

    // Wait for cache operation to finish
    // Set timeout before polling...
    Set_Timeout(GTIMEOUT);

    // Wait for transition to finish for max timeout time...
    while( Get_Timeout() && ( *(int*)L2INV & 0x0001 ) );

    // Check if we got timeout error while waiting
    if (!Get_Timeout())
    {
        GEL_TextOut( "Invalidate All Cache... Timeout Error #03!\n",,2,,,);
    }

    Kill_Timeout();

    GEL_TextOut( "Invalidate All Cache... Done.\n" );
}

/****************************************************************************
 *
 * NAME
 *      OnPreFileLoaded
 *
 * PURPOSE:
 *      Called by CCS when you do in menu File->LoadProgram, File->LoadSymbols,
 *      etc, before loading anything.
 *
 * USAGE
 *      This routine is a callback routine and called by CCS only.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
OnPreFileLoaded()
{
    if (ON_FILE_LOAD_CODE_ENABLE == 1)
    {
        // System reset to assure reliablity between projects
        if (SYSTEM_RESET_BEFORE_FILE_LOAD_ENABLE == 1)
        {
            GEL_TextOut( "System Reset...\n" );
            GEL_AdvancedReset("System Reset");
            GEL_TextOut( "System Reset... Done.\n" );
            // Let core get stable from reset
            Wait_Soft(4000);
        }

        // Purge all the cache
        Invalidate_Cache();

        // Disable interrupts
        IER = 0;

        // Is used to be sure dsp is ready to load a file
        // Can be comment out if not needed...  (Must be used if using DDR, see OnReset() which is called by CCS when GEL_Reset() is executed)
        GEL_TextOut( "GEL Reset...\n" );
        GEL_Reset();
        GEL_TextOut( "GEL Reset... Done.\n" );

        // Slow down the speed at which the cores get their code loaded to maintain JTAG stability when using multiple cores simultaneously.
        Wait_Soft(5000 + (DNUM * 10000));
    }
}


/****************************************************************************
 *
 * NAME
 *      StartUp
 *
 * PURPOSE:
 *      Perform CCS Memory Map configuration.
 *      This function is called each time CCS is started.
 *
 * USAGE
 *      This routine is a callback routine and called by CCS only.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
StartUp( )
{
    Setup_Memory_Map( );
}

/*--------------------------------------------------------------*/
/* OnTargetConnect()                                            */
/* This function is called by CCS when you do Debug->Connect on */
/* CCS 3.X.                                                     */
/*--------------------------------------------------------------*/
OnTargetConnect()
{
    /*------------------------------------------------------*/
    /* GEL_Reset() is used to deal with the worst case      */
    /* senario of unknown target state.  If for some reason */
    /* a reset is not desired upon target connection,       */
    /* GEL_Reset() may be removed and replaced with         */
    /* something "less brutal" like a cache initialization  */
    /* function.                                            */
    /*------------------------------------------------------*/
    //GEL_Reset();
    //Set_DSP_Cache();
    if (ON_TARGET_CONNECT_CODE_ENABLE == 1)
    {
        if (DNUM == 0)
        {
            // Validates if emulation boot mode
            if (DEVSTAT & 0x0000000E)
            {
                GEL_TextOut("No initialization performed since bootmode = %x \n",,,,,(DEVSTAT >> 1 ) & 0xF);
                GEL_TextOut("You can manually initialize with GlobalDefaultSetup\n");
            }
            else
            {
                // Comment the following line at production application test
                // when the application need to initialize everything, but not the
                // GEL file.
                Global_Default_Setup();
            }
        }
        else
        {
            // Set DSP cache to pre defined values...
            Set_DSP_Cache();
        }
        // Slow down the speed at which the cores connect to maintain JTAG stability when using multiple cores simultaneously.
        Wait_Soft(5000 + (DNUM * 5000));
    }
}


/*--------------------------------------------------------------*/
/* OnReset()                                                    */
/* This function is called by CCS when you do Debug->Reset.    */
/* The goal is to put the C6x into a known good state with      */
/* respect to cache, edma and interrupts.                       */
/*--------------------------------------------------------------*/
OnReset( int nErrorCode )
{
}

/*--------------------------------------------------------------*/
/* xmc_setup()                                                  */
/* XMC MPAX register setting to access DDR3 config space        */
/*--------------------------------------------------------------*/

#define XMC_BASE_ADDR (0x08000000)
#define XMPAX2_L     (*(int*)(XMC_BASE_ADDR + 0x00000010))
#define XMPAX2_H     (*(int*)(XMC_BASE_ADDR + 0x00000014))

xmc_setup()
{  
    /* mapping for ddr emif registers XMPAX*2 */
    XMPAX2_L = 0x100000FF;     /* replacement addr + perm*/
    XMPAX2_H =  0x2100000B;    /* base addr + seg size (64KB)*/ //"1B"-->"B" by xj
    GEL_TextOut("XMC setup complete.\n","2");
}

/*--------------------------------------------------------------*/
/* ddr3_setup()                                                  */
/* DDR3 initialization                                          */
/*--------------------------------------------------------------*/


int flag;


ddr3_setup_auto_lvl_1333()
{
    int i,TEMP,startlo, stoplo,starthi, stophi;
    KICK0 = KICK0_UNLOCK;
    KICK1 = KICK1_UNLOCK;

    /* Wait for PLL to lock = min 500 ref clock cycles. 
       With refclk = 100MHz, = 5000 ns = 5us */
    Delay_milli_seconds(1);

    /***************** 3.2 DDR3 PLL Configuration ************/
    /* Done before */

    /**************** 3.0 Leveling Register Configuration ********************/
    /* Using partial automatic leveling due to errata */

    /**************** 3.3 Leveling register configuration ********************/
    DDR3_CONFIG_REG_0 &= ~(0x007FE000);  // clear ctrl_slave_ratio field
    DDR3_CONFIG_REG_0 |= 0x00200000;     // set ctrl_slave_ratio to 0x100
    DDR3_CONFIG_REG_12 |= 0x08000000;    // Set invert_clkout = 1
    DDR3_CONFIG_REG_0 |= 0xF;            // set dll_lock_diff to 15

    //From 4.2.1 Executing Partial Automatic Leveling -- Start
    DDR3_CONFIG_REG_23 |= 0x00000200;    //Set bit 9 = 1 to use forced ratio leveling for read DQS
    //From 4.2.1 Executing Partial Automatic Leveling -- End

    //Values with invertclkout = 1
    /**************** 3.3 Partial Automatic Leveling ********************/
    DATA0_WRLVL_INIT_RATIO = 0x5E;
    DATA1_WRLVL_INIT_RATIO = 0x5E;
    DATA2_WRLVL_INIT_RATIO = 0x5E;
    DATA3_WRLVL_INIT_RATIO = 0x51;
    DATA4_WRLVL_INIT_RATIO = 0x38;
    DATA5_WRLVL_INIT_RATIO = 0x3A;
    DATA6_WRLVL_INIT_RATIO = 0x24;
    DATA7_WRLVL_INIT_RATIO = 0x20;
    DATA8_WRLVL_INIT_RATIO = 0x44;

    DATA0_GTLVL_INIT_RATIO = 0xDD;
    DATA1_GTLVL_INIT_RATIO = 0xDD;
    DATA2_GTLVL_INIT_RATIO = 0xBE;
    DATA3_GTLVL_INIT_RATIO = 0xCA;
    DATA4_GTLVL_INIT_RATIO = 0xA9;
    DATA5_GTLVL_INIT_RATIO = 0xA7;
    DATA6_GTLVL_INIT_RATIO = 0x9E;
    DATA7_GTLVL_INIT_RATIO = 0xA1;
    DATA8_GTLVL_INIT_RATIO = 0xBA;

    //Do a PHY reset. Toggle DDR_PHY_CTRL_1 bit 15 0->1->0
    DDR_DDRPHYC &= ~(0x00008000);
    DDR_DDRPHYC |= (0x00008000);
    DDR_DDRPHYC &= ~(0x00008000);

    /***************** 3.4 Basic Controller and DRAM Configuration ************/
    DDR_SDRFC    = 0x00005162;    // enable configuration 

    /* DDR_SDTIM1   = 0x1113783C; */
    TEMP = 0;
    TEMP |= 0x8 << 25; // T_RP bit field 28:25
    TEMP |= 0x8 << 21; // T_RCD bit field 24:21
    TEMP |= 0x9 << 17; // T_WR bit field 20:17
    TEMP |= 0x17 << 12; // T_RAS bit field 16:12
    TEMP |= 0x20 << 6; // T_RC bit field 11:6
    TEMP |= 0x7 << 3; // T_RRD bit field 5:3
    TEMP |= 0x4; // T_WTR bit field 2:0
    DDR_SDTIM1 = TEMP;

    /* DDR_SDTIM2   = 0x30717FE3; */
    TEMP = 0;
    TEMP |= 0x3 << 28; // T_XP bit field 30:28
    TEMP |= 0x71 << 16; // T_XSNR bit field 24:16
    TEMP |= 0x1ff << 6; // T_XSRD bit field 15:6
    TEMP |= 0x4 << 3; // T_RTP bit field 5:3
    TEMP |= 0x3; // T_CKE bit field 2:0
    DDR_SDTIM2 = TEMP;

    /*  DDR_SDTIM3   = 0x559F86AF; */
    TEMP = 0;
    TEMP |= 0x5 << 28; // T_PDLL_UL bit field 31:28 (fixed value)
    TEMP |= 0x5 << 24; // T_CSTA bit field 27:24 (fixed value)
    TEMP |= 0x4 << 21; // T_CKESR bit field 23:21
    TEMP |= 0x3f << 15; // T_ZQCS bit field 20:15
    TEMP |= 0x6a << 4; // T_RFC bit field 12:4
    TEMP |= 0xf; // T_RAS_MAX bit field 3:0 (fixed value)
    DDR_SDTIM3 = TEMP; 

    DDR_DDRPHYC  = 0x0010010F;

    DDR_ZQCFG    = 0x70073214; 

    DDR_PMCTL    = 0x0;

    DDR_SDRFC = 0x00005162; // enable configuration

    /* DDR_SDCFG    = 0x63062A32; */
    /* New value with DYN_ODT disabled and SDRAM_DRIVE = RZQ/7 //0x63222A32;    // last config write DRAM init occurs */
    TEMP = 0;
    TEMP |= 0x3 << 29; // SDRAM_TYPE bit field 31:29 (fixed value)
    TEMP |= 0x0 << 27; // IBANK_POS bit field 28:27
    TEMP |= 0x3 << 24; // DDR_TERM bit field 26:24
    TEMP |= 0x0 << 21; // DYN_ODT bit field 22:21
    TEMP |= 0x1 << 18; // SDRAM_DRIVE bit field 19:18
    TEMP |= 0x2 << 16; // CWL bit field 17:16
    TEMP |= 0x0 << 14; // NM bit field 15:14
    TEMP |= 0xA << 10; // CL bit field 13:10
    TEMP |= 0x4 << 7; // ROWSIZE bit field 9:7
    TEMP |= 0x3 << 4; // IBANK bit field 6:4
    TEMP |= 0x0 << 3; // EBANK bit field 3:3
    TEMP |= 0x2; // PAGESIZE bit field 2:0
    DDR_SDCFG = TEMP;

    //Wait 600us for HW init to complete
    Delay_milli_seconds(1);

    DDR_SDRFC = 0x00001450;       //Refresh rate = (7.8*666MHz)

    /**************** 4.2.1 Executing Partial Automatic Leveling ********************/

    DDR_RDWR_LVL_RMP_CTRL = 0x80000000; //enable full leveling

    DDR_RDWR_LVL_CTRL = 0x80000000; //Trigger full leveling - This ignores read DQS leveling result and uses ratio forced value  

    //(0x34) instead
    //Wait for min 1048576 DDR clock cycles for leveling to complete = 1048576 * 1.5ns = 1572864ns = 1.57ms.
    //Actual time = ~10-15 ms
    Delay_milli_seconds(1);
    GEL_TextOut("\nDDR3 initialization is complete.\n");
}

/****************************************************************************
 *
 * NAME
 *      Reset
 *
 * PURPOSE:
 *      Performs the Gel Reset
 *
 * USAGE
 *      This function can be called as below.
 *       GEL_Reset()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/

hotmenu Reset()
{
    GEL_Reset();
}

/****************************************************************************
 *
 * NAME
 *      Init XMC
 *
 * PURPOSE:
 *      Performs the Extended Memory Controller Setup
 *
 * USAGE
 *      This function can be called as below.
 *       InitXMC()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu InitXMC()
{
    xmc_setup();
}

/****************************************************************************
 *
 * NAME
 *      Init Emif
 *
 * PURPOSE:
 *      Performs the External Memory Interface initialization
 *
 * USAGE
 *      This function can be called as below.
 *       InitEmif()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu InitEmif()
{

    ddr3_setup_auto_lvl_1333(0);
}

prog_pll1_values(unsigned int pll_multiplier, unsigned int pll_divider, unsigned int odiv)
{
    int TEMP;

    /* Check the Range for the parameters */

    if (odiv > 15)
    {
        GEL_TextOut ( " invalid output divide range, should be less than 15... \n");
    }

    if (pll_multiplier > 4095)
    {
        GEL_TextOut ( " invalid pll multiplier range, should be less than 4095... \n");
    }

    if (pll_divider > 63)
    {
        GEL_TextOut ( " invalid pll multiplier range, should be less than 63... \n");
    }

    /* Set the PLL Multiplier, Divider, BWADJ                                    *
     * The PLLM[5:0] bits of the multiplier are controlled by the PLLM Register  *
     * inside the PLL Controller and the PLLM[12:6] bits are controlled by the   *
     * chip-level MAINPLLCTL0 Register.                                          *
     * PLL Control Register (PLLM)  Layout                                       *
     * |31...6   |5...0        |                                                 *
     * |Reserved |PLLM         |                                                 *
     *                                                                           *
     * Main PLL Control Register (MAINPLLCTL0)                                   *
     * |31...24   |23...19   |18...12    | 11...6   |5...0 |                     *
     * |BWADJ[7:0]| Reserved |PLLM[12:6] | Reserved | PLLD |                     */

    /* Set pll multipler (13 bit field) */
    PLL1_PLLM     = (pll_multiplier & 0x0000003F); /* bits[5:0]  */
    TEMP          = (pll_multiplier & 0x1FC0) >> 6;/* bits[12:6] */
    MAINPLLCTL0  &=~(0x0007F000);                /*Clear PLLM field */
    MAINPLLCTL0  |=((TEMP << 12) & 0x0007F000);

   /* Set the BWADJ     (12 bit field)                                          *
     * BWADJ[11:8] and BWADJ[7:0] are located in MAINPLLCTL0 and MAINPLLCTL1     *
     * registers. BWADJ[11:0] should be programmed to a value equal to half of   *
     * PLLM[12:0] value (round down if PLLM has an odd value)                    *
     * Example: If PLLM = 15, then BWADJ = 7                                     */
    TEMP = ((pll_multiplier + 1) >> 1) - 1; /* Divide the pllm by 2 */
    MAINPLLCTL0 &=~(0xFF000000);  /* Clear the BWADJ Field */
    MAINPLLCTL0 |=  ((TEMP << 24) & 0xFF000000);
    MAINPLLCTL1 &=~(0x0000000F);   /* Clear the BWADJ field */
    MAINPLLCTL1 |= ((TEMP >> 8) & 0x0000000F);

    /* Set the pll divider (6 bit field)                                         *
     * PLLD[5:0] is located in MAINPLLCTL0                                       */
    MAINPLLCTL0   &= ~(0x0000003F);    /* Clear the Field */
    MAINPLLCTL0   |= (pll_divider & 0x0000003F);

    /* Set the OUTPUT DIVIDE (4 bit field) in SECCTL */
    PLL1_SECCTL    &= ~(0x00780000);     /* Clear the field       */
    PLL1_SECCTL   |= ((odiv << 19) & 0x00780000) ;
 
}

menuitem "EVMC6670L HW Setup";

/****************************************************************************
 *
 * NAME
 *      Init PLL
 *
 * PURPOSE:
 *      Performs the main PLL initialization
 *
 * USAGE
 *      This function can be called as below.
 *       Init_PLL()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 * NOTE
 *     Note that this function requires pll_mult and pll_div arguments to be
 *     actual register values, i.e., the values are original values - 1
 *     (pll_* = calculated_value_of_pll_* - 1)
 *
 ****************************************************************************/
hotmenu Init_PLL(int pll_mult, int pll_div )
{
    int i, TEMP;
    /* Default dividers */
    unsigned int div2=3, div5=5, div8=64;
    int dsp_freq;
    int dsp_freM,dsp_freD;

    GEL_TextOut ( "Main PLL (PLL1) Setup ... \n");
    /*Unlock Boot Config*/
    KICK0 = 0x83E70B13;
    KICK1 = 0x95A4F1E0;

    // Only core0 can set PLL
    if (DNUM == 0)
    {

        /* Wait for Stabilization time (min 100 us)                                *
         * The below loop is good enough for the Gel file to get minimum of        *
         * 100 micro seconds, this should be appropriately modified for port       *
         * to a C function                                                         *
         * Minimum delay in GEL can be 1 milli seconds, so program to 1ms=1000us,  *
         * more than required, but should be Okay                                  */
        Delay_milli_seconds(1);

        /* If PLL previously configured in RBL, avoid di/dt supply excursion by    *
         * matching PLL output to RefClk rate                                      *
         * if RBL configures the PLL, the BYPASS bit would be set to '0'           */
        TEMP = PLL1_SECCTL &  0x00800000; /* Check the Bit 23 value */

        if (TEMP != 0) /* PLL BYPASS is enabled, we assume if not in Bypass ENSAT = 1 */
        {
            GEL_TextOut ( "PLL in Bypass ... \n");

            /* Usage Note 9: For optimal PLL operation, the ENSAT bit in the PLL control *
             * registers for the Main PLL, DDR3 PLL, and PA PLL should be set to 1.      *
             * The PLL initialization sequence in the boot ROM sets this bit to 0 and    *
             * could lead to non-optimal PLL operation. Software can set the bit to the  *
             * optimal value of 1 after boot                                             *
             * Ref: http://www.ti.com/lit/er/sprz334b/sprz334b.pdf                       *
             * |31...7   |6     |5 4       |3...0      |                                 *
             * |Reserved |ENSAT |Reserved  |BWADJ[11:8]|                                 */

            MAINPLLCTL1 = MAINPLLCTL1 | 0x00000040;

            /* Clear PLLENSRC bit */
            PLL1_PLLCTL &= ~(1 << 5);

            /* Clear PLLEN bit */
            PLL1_PLLCTL &= ~(1 << 0);

            /* Wait for 4 RefClks   *
             * Assuming slowest Ref clock of 25MHz, min: 160 ns delay */
            Delay_milli_seconds(1);

            /* Bypass needed to perform PWRDN cycle for C6670 and C6678                  *
             * Needed on all devices when in NOBOOT, I2C or SPI boot modes               *
             * Ref: Figure 4-2 of http://www.ti.com/lit/ug/sprugv2a/sprugv2a.pdf         *
             * PLL Secondary Control Register (SECCTL)  Layout                           *
             * |31...24  |23     |22...19       |18...0   |                              *
             * |Reserved |BYPASS |OUTPUT DIVIDE |Reserved |                              */
            PLL1_SECCTL |= 0x00800000; /* Set the Bit 23 */

            /* Advisory 8: Multiple PLLs May Not Lock After Power-on Reset Issue         *
             * In order to ensure proper PLL startup, the PLL power_down pin needs to be *
             * toggled. This is accomplished by toggling the PLLPWRDN bit in the PLLCTL  *
             * register. This needs to be done before the main PLL initialization        *
             * sequence                                                                  *
             * Ref: Figure 4-1 of http://www.ti.com/lit/ug/sprugv2a/sprugv2a.pdf         *
             * PLL Control Register (PLLCTL)  Layout                                     *
             * |31...4   |3      |2        |1        |0        |                         *
             * |Reserved |PLLRST |Reserved |PLLPWRDN |Reserved |                         */

            PLL1_PLLCTL   |= 0x00000002; /*Power Down the PLL */

            /* Stay in a loop such that the bit is set for 5 s (minimum) and           *
             * then clear the bit.                                                      */

            Delay_milli_seconds(1); /* This is more than required delay */  

            /* Power up the PLL */  
            PLL1_PLLCTL   &= ~(0x00000002); 

        }

        /* Place PLL in Reset, In PLLCTL, write PLLRST = 1 (PLL is reset)         */
        PLL1_PLLCTL |= 0x00000008;

        /* Wait for PLL Reset assertion Time (min: 50 us)                          *
         * Minimum delay in GEL can be 1 milli seconds, so program to 1ms=1000us,  *
         * more than required, but should be Okay                                  */
        //Delay_milli_seconds(1);

        /* Program the necessary multipliers/dividers and BW adjustments             */
        prog_pll1_values(pll_mult, pll_div, 1);

        /* go stat bit needs to be zero here    */
        /* Read the GOSTAT bit in PLLSTAT to make sure the bit returns to 0 to      *  
         * indicate that the GO operation has completed                             */
        /* wait for the GOSTAT, but don't trap if lock is never read */
        for (i = 0; i < 1000; i++)
        {
            if ( (PLL1_STAT & 0x00000001) == 0 ) {
                break;
            }
        }
        if ( i == 1000 ) {
            GEL_TextOut ( "Error while waiting for GOSTAT bit returning to 0 ... \n");
            return(-1);
        }

        /* Set PLL dividers if needed */
        PLL1_DIV2 = (0x8000) | (div2 - 1);
        PLL1_DIV5 = (0x8000) | (div5 - 1);
        PLL1_DIV8 = (0x8000) | (div8 - 1);

        /* Program ALNCTLn */
        /* Set bit 1, 4 and 7 */
        PLL1_ALNCTL |= ( (1 << 1) | (1 << 4) | (1 << 7));

        /* Set GOSET bit in PLLCMD to initiate the GO operation to change the divide *
         * values and align the SYSCLKs as programmed                                */
        PLL1_CMD     |= 0x00000001;

        /* wait for the phase adj */
        Delay_milli_seconds(1);

        /* Read the GOSTAT bit in PLLSTAT to make sure the bit returns to 0 to      *  
         * indicate that the GO operation has completed                             */

        /* wait for the GOSTAT, but don't trap if lock is never read */
        for (i = 0; i < 1000; i++)
        {

            if ( (PLL1_STAT & 0x00000001) == 0 ) {
                break;
            }

        }

        if ( i == 1000 ) {
            GEL_TextOut ( "Error while waiting for GOSTAT bit returning to 0 ... \n");
            return(-1);
        }

        /* Wait for the PLL Reset duration time (min: 7us    )                */
        Delay_milli_seconds(1);

        /*In PLLCTL, write PLLRST = 0 to bring PLL out of reset */
        PLL1_PLLCTL &= ~(0x00000008);

        /* 
         * PLL Lock Delay needs to be 500 RefClk periods * (PLLD + 1)
         * i.e., Wait for at least 500 * CLKIN cycles * (PLLD + 1) (PLL lock time)
         * Using 2000 25ns RefClk periods per DM
         * Wait for PLL to lock min 50 micro seconds
         * 
         * */
        Delay_milli_seconds(1);

        PLL1_SECCTL &= ~(0x00800000); /* Release Bypass */

        /* Set the PLLEN */
        PLL1_PLLCTL |= (1 << 0);

        // Compute the real dsp freq (*100)
        dsp_freq = (((REF_CLOCK_KHZ/10) * ((pll_mult+1)/2))/(pll_div+1));

        // Displayed frequency setup
        // dsp freq in MHz
        dsp_freM = dsp_freq / 100;

        // dsp freq first decimal if freq expressed in MHz
        dsp_freD = ((dsp_freq - dsp_freM * 100) + 5) / 10;

        // Add roundup unit to MHz displayed and reajust decimal value if necessary...
        if (dsp_freD > 9)
        {
            dsp_freD = dsp_freD - 10;
            dsp_freM = dsp_freM + 1;
        }

        // Print freq info...
        GEL_TextOut( "PLL1 Setup for DSP @ %d.%d MHz.\n",,,,, dsp_freM, dsp_freD );
        GEL_TextOut( "           SYSCLK2 = %f MHz, SYSCLK5 = %f MHz.\n",,,,, ((float)(dsp_freq/100)/div2), ((float)(dsp_freq/100)/div5));
        GEL_TextOut( "           SYSCLK8 = %f MHz.\n",,,,, ((float)(dsp_freq/100)/div8));
        GEL_TextOut( "PLL1 Setup... Done.\n" );
        return (0);
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PLL1.\n",,2,,,DNUM);
        return(-1);
    }
}


/****************************************************************************
 *
 * NAME
 *      Set_DSP_Cache
 *
 * PURPOSE:
 *      Setup the DSP caches with predefined cache size.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_DSP_Cache()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_DSP_Cache( )
{
    int l1p, l1d, l2;

    GEL_TextOut( "Setup Cache... \n");

    // Modify for the desired cache settings needed
    CACHE_L1PCFG = 7;           // L1P on, MAX size
    //CACHE_L1DCFG = 7;           // L1D on, MAX size
    CACHE_L1DCFG = 1;           // L1D on, 4K cache, 28K SRAM   //manu
    //CACHE_L1DCFG = 0;           // L1D on, 0K cache, 32K SRAM   //manu
    CACHE_L2CFG  = 0;           // L2 off, use as RAM

    l1p = (CACHE_L1PCFG & 0x7);

    if ( l1p == 0 )
    {
        GEL_TextOut( "L1P = 0K   \n" );
    }
    if ( l1p == 1 )
    {
        GEL_TextOut( "L1P = 4K   \n" );
    }
    if ( l1p == 2 )
    {
        GEL_TextOut( "L1P = 8K   \n" );
    }
    if ( l1p == 3 )
    {
        GEL_TextOut( "L1P = 16K   \n" );
    }
    if ( l1p >= 4 )
    {
        GEL_TextOut( "L1P = 32K   \n" );
    }

    l1d = (CACHE_L1DCFG & 0x7);
    if ( l1d == 0 )
    {
        GEL_TextOut( "L1D = 0K   \n" );
    }
    if ( l1d == 1 )
    {
        GEL_TextOut( "L1D = 4K   \n" );
    }
    if ( l1d == 2 )
    {
        GEL_TextOut( "L1D = 8K   \n" );
    }
    if ( l1d == 3 )
    {
        GEL_TextOut( "L1D = 16K   \n" );
    }
    if ( l1d >= 4 )
    {
        GEL_TextOut( "L1D = 32K   \n" );
    }

    l2 = (CACHE_L2CFG & 0x7);
    if ( l2 == 0 )
    {
        GEL_TextOut( "L2 = ALL SRAM   \n" );
    }
    if ( l2 == 1 )
    {
        GEL_TextOut( "L2 = 31/32 SRAM   \n" );
    }
    if ( l2 == 2 )
    {
        GEL_TextOut( "L2 = 15/16 SRAM   \n" );
    }
    if ( l2 == 3 )
    {
        GEL_TextOut( "L2 = 7/8 SRAM   \n" );
    }
    if ( l2 == 4 )
    {
        GEL_TextOut( "L2 = 3/4 SRAM   \n" );
    }
    if ( l2 == 5 )
    {
        GEL_TextOut( "L2 = 1/2 SRAM   \n" );
    }
    if ( l2 >= 6 )
    {
        GEL_TextOut( "L2 = ALL CACHE   \n" );
    }

    GEL_TextOut( "Setup Cache... Done.\n");
}

/****************************************************************************
 *
 * NAME
 *      Set_Psc_All_On
 *
 * PURPOSE:
 *      Enable all PSC modules and DSP power domains on ALWAYSON, and wait
 *      for these power transitions to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Psc_All_On()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Psc_All_On( )
{
    unsigned int i=0;

    // Only core0 can set PSC
    if (DNUM == 0)
    {
        GEL_TextOut( "Power on all PSC modules and DSP domains... \n");

        Set_PSC_State(PD0, LPSC_SMARTRFLX, PSC_ENABLE);
        Set_PSC_State(PD0, LPSC_DDR3, PSC_ENABLE);
        Set_PSC_State(PD0, LPSC_TCP3E, PSC_ENABLE);
        Set_PSC_State(PD0, LPSC_VCP2A, PSC_ENABLE);
        Set_PSC_State(PD1, LPSC_DEBUG, PSC_ENABLE);
        Set_PSC_State(PD1, LPSC_TETB, PSC_ENABLE);
        Set_PSC_State(PD2, LPSC_PA, PSC_ENABLE);
        Set_PSC_State(PD2, LPSC_SGMII, PSC_ENABLE);
        Set_PSC_State(PD2, LPSC_SA, PSC_ENABLE);
        Set_PSC_State(PD3, LPSC_PCIE, PSC_ENABLE);
        Set_PSC_State(PD4, LPSC_SRIO, PSC_ENABLE);
        Set_PSC_State(PD5, LPSC_HYPER, PSC_ENABLE);
        //Set_PSC_State(PD6, LPSC_RESERV, PSC_ENABLE);
        Set_PSC_State(PD7, LPSC_MSMCRAM, PSC_ENABLE);
        Set_PSC_State(PD8, LPSC_RACA_RACB, PSC_ENABLE);
        Set_PSC_State(PD8, LPSC_TAC, PSC_ENABLE);
        Set_PSC_State(PD9, LPSC_FFTCA_FFTCB, PSC_ENABLE);
        Set_PSC_State(PD10, LPSC_AIF2, PSC_ENABLE);
        Set_PSC_State(PD11, LPSC_TCP3DA, PSC_ENABLE);
        Set_PSC_State(PD12, LPSC_VCP2B, PSC_ENABLE);
        Set_PSC_State(PD12, LPSC_VCP2C, PSC_ENABLE);
        Set_PSC_State(PD12, LPSC_VCP2D, PSC_ENABLE);
        Set_PSC_State(PD13, LPSC_C0_TIM0, PSC_ENABLE);
        Set_PSC_State(PD14, LPSC_C1_TIM1, PSC_ENABLE);
        Set_PSC_State(PD14, LPSC_C1_RSA, PSC_ENABLE);
        Set_PSC_State(PD15, LPSC_C2_TIM2, PSC_ENABLE);
        Set_PSC_State(PD15, LPSC_C2_RSA, PSC_ENABLE);
        Set_PSC_State(PD16, LPSC_C3_TIM3, PSC_ENABLE);
        Set_PSC_State(PD17, LPSC_TCP3dB, PSC_ENABLE);

        GEL_TextOut( "Power on all PSC modules and DSP domains... Done.\n" );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
    }
}

/****************************************************************************
 *
 * NAME
 *      Set_PSC_State
 *
 * PURPOSE:
 *      Set a new power state for the specified domain id in a power controler
 *      domain. Wait for the power transition to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
 *
 *      pd    - (i) power domain.
 *
 *      id    - (i) module id to use for module in the specified power domain
 *
 *      state - (i) new state value to set
 *                  0 = RESET
 *                  1 = SYNC RESET
 *                  2 = DISABLE
 *                  3 = ENABLE
 *
 * RETURN VALUE
 *      0 if ok, !=0 for error
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
{
    unsigned int* mdctl;
    unsigned int* mdstat;
    unsigned int* pdctl;
    int ret=0;

    // Only core0 can set PSC
    if (DNUM == 0)
    {
        mdctl = ( unsigned int* )(PSC_MDCTL_BASE + ( 4 * id ));
        mdstat = ( unsigned int* )( PSC_MDSTAT_BASE + ( 4 * id ));
        pdctl = ( unsigned int* )(PSC_PDCTL_BASE + ( 4 * pd ));

        // If state is already set, do nothing
        if ( ( *mdstat & 0x1f ) == state )
        {
            return(0);
        }

        // Wait for GOSTAT to clear
        Set_Timeout(GTIMEOUT);
        while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );

        // Check if we got timeout error while waiting
        if (!Get_Timeout())
        {
            GEL_TextOut( "Set_PSC_State... Timeout Error #01 pd=%d, md=%d!\n",,2,,,pd,id);
            ret=1;
        }
        else
        {
            // Set power domain control
            *pdctl = (*pdctl) | 0x00000001;

            // Set MDCTL NEXT to new state
            *mdctl = ((*mdctl) & ~(0x1f)) | state;

            // Start power transition by setting PTCMD GO to 1
            PSC_PTCMD = (PSC_PTCMD) | (0x1<<pd);

            // Wait for PTSTAT GOSTAT to clear
            Set_Timeout(GTIMEOUT);
            while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );

            // Check if we got timeout error while waiting
            if (!Get_Timeout())
            {
                GEL_TextOut( "Set_PSC_State... Timeout Error #02 pd=%d, md=%d!\n",,2,,,pd,id);
                ret=2;
            }
            else
            {
                // Verify state changed
                Set_Timeout(GTIMEOUT);
                while(Get_Timeout() && ( *mdstat & 0x1f ) != state );

                // Check if we got timeout error while waiting
                if (!Get_Timeout())
                {
                    if ((pd == 2) && (id == 9) ) {
                        GEL_TextOut( "Security Accelerator disabled!\n",,2,,);
                    } else {
                        GEL_TextOut( "Set_PSC_State... Timeout Error #03 pd=%d, md=%d!\n",,2,,,pd,id);
                    }
                    ret=3;
                }
            }
        }

        // Kill the currently running timeout
        Kill_Timeout();
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
    }

    return(ret);
}

/****************************************************************************
 *
 * NAME
 *      Set_Timeout
 *
 * PURPOSE:
 *      Starts a timeout period of msec. The running timeout period can be
 *      query with Get_Timeout. To kill a running timeout before the end,
 *      call Kill_Timeout. Only one timeout period can be used at any time.
 *      A timeout period can be used to measure a period of time while doing
 *      anything else. Not accurate, sets timer at least as big as desired.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Timeout(msec)
 *
 *      msec - (i) timeout period in msec (not very precise < sec range)
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_Timeout(msec)
{
    // Cancel the current timer if not already expired
    GEL_CancelTimer(TIMEOUT_ID);

    // Starts the timeout period
    _GEL_Global_Timeout1=1;

    // Setup a callback routine with specified timeout
    GEL_SetTimer(msec, TIMEOUT_ID, "_Timeout_Callback()");
}

/****************************************************************************
 *
 * NAME
 *      Get_Timeout
 *
 * PURPOSE:
 *      Query the running state of a timeout period started by Set_Timeout.
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Get_Timeout()
 *
 * RETURN VALUE
 *      0:expired, 1:running
 *
 * REFERENCE
 *
 ****************************************************************************/
Get_Timeout()
{
    if (!_GEL_Global_Timeout1)
    {
        // Cancel the current timer
        GEL_CancelTimer(TIMEOUT_ID);
    }

    // Return the global timeout status 1=running, 0=expired
    return _GEL_Global_Timeout1;
}

/****************************************************************************
 *
 * NAME
 *      Kill_Timeout
 *
 * PURPOSE:
 *      Cancel a running timeout period before it expires
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Kill_Timeout()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Kill_Timeout()
{
    // Cancel the current timer
    GEL_CancelTimer(TIMEOUT_ID);

    // The timeout period is expired
    _GEL_Global_Timeout1=0;
}

/****************************************************************************
 *
 * NAME
 *      _Timeout_Callback
 *
 * PURPOSE:
 *      Internal Callback function used by Set_timeout
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine must not be called by itself.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
_Timeout_Callback()
{
    // The timeout period is expired
    _GEL_Global_Timeout1=0;
}

/****************************************************************************
 *
 * NAME
 *      Setup_Memory_Map
 *
 * PURPOSE:
 *      Setup the Memory Map for EVMC6670L.
 *      Defined memory location avoid debugger access outside these locations.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Setup_Memory_Map()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *      Based on TMS320C6670 datasheet.
 *
 ****************************************************************************/
hotmenu Setup_Memory_Map( )
{
    GEL_TextOut("Setup_Memory_Map...\n",,);

    GEL_MapOn( );
    GEL_MapReset( );

    if (AVV_MEM_MAP == 1)
    {
        GEL_MapAddStr( 0x00800000, 0, 0x00004000, "PRAM", 0 );   // Local L2 SRAM L2RAM_INPUT_DAT_MEM
        GEL_MapAddStr( 0x00804000, 0, 0x00000040, "PRAM", 0 );   // Local L2 SRAM L2RAM_TEST_RESULTS
        GEL_MapAddStr( 0x00804040, 0, 0x000fbfc0, "R|W|AS4", 0 );   // Local L2 SRAM
    }
    else
    {
        GEL_MapAddStr( 0x00800000, 0, 0x00100000, "R|W|AS4", 0 );   // Local L2 SRAM
    }
    GEL_MapAddStr( 0x00E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Local L1P SRAM
    GEL_MapAddStr( 0x00F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Local L1D SRAM
    GEL_MapAddStr( 0x01000000, 0, 0x01C00000, "R|W|AS4", 0 );   // C66x CorePac Registers
    GEL_MapAddStr( 0x01D00000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 0
    GEL_MapAddStr( 0x01D08000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 1
    GEL_MapAddStr( 0x01D10000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 2
    GEL_MapAddStr( 0x01D18000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 3
    GEL_MapAddStr( 0x01D20000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 4
    GEL_MapAddStr( 0x01D28000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 5
    GEL_MapAddStr( 0x01D30000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 6
    GEL_MapAddStr( 0x01D38000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 7
    GEL_MapAddStr( 0x01D40000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 8
    GEL_MapAddStr( 0x01D48000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 9
    GEL_MapAddStr( 0x01D50000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 10
    GEL_MapAddStr( 0x01D58000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 11
    GEL_MapAddStr( 0x01D60000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 12
    GEL_MapAddStr( 0x01D68000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 13
    GEL_MapAddStr( 0x01D70000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 14
    GEL_MapAddStr( 0x01D78000, 0, 0x00000080, "R|W|AS4", 0 );   // Tracer 15
    GEL_MapAddStr( 0x01F00000, 0, 0x00080000, "R|W|AS4", 0 );   // AIF2 Control
    GEL_MapAddStr( 0x01F80000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_B - FEI Control
    GEL_MapAddStr( 0x01F90000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_B - BEI Control
    GEL_MapAddStr( 0x01FA0000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_B - GCCP 0 Control
    GEL_MapAddStr( 0x01FC0000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_B - GCCP 1 Control
    GEL_MapAddStr( 0x02000000, 0, 0x00090000, "R|W|AS4", 0 );   // Packet Accelerator Configuration
    GEL_MapAddStr( 0x02090000, 0, 0x00030000, "R|W|AS4", 0 );   // Ethernet Switch Subsystem Configuration
    GEL_MapAddStr( 0x020C0000, 0, 0x00040000, "R|W|AS4", 0 );   // Crypto Subsystem Configuration
    GEL_MapAddStr( 0x02100000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_A - FEI Control
    GEL_MapAddStr( 0x02110000, 0, 0x00010000, "R|W|AS4", 0 );   // RAC_A - BEI Control
    GEL_MapAddStr( 0x02120000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_A - GCCP 0 Control
    GEL_MapAddStr( 0x02140000, 0, 0x00020000, "R|W|AS4", 0 );   // RAC_A - GCCP 1 Control
    GEL_MapAddStr( 0x02180000, 0, 0x00008000, "R|W|AS4", 0 );   // TAC - FEI Control
    GEL_MapAddStr( 0x02188000, 0, 0x00008000, "R|W|AS4", 0 );   // TAC - BEI Control
    GEL_MapAddStr( 0x02190000, 0, 0x00010000, "R|W|AS4", 0 );   // TAC - SGCCP 0 Control
    GEL_MapAddStr( 0x021A0000, 0, 0x00010000, "R|W|AS4", 0 );   // TAC - SGCCP 1 Control
    GEL_MapAddStr( 0x021C0000, 0, 0x00000400, "R|W|AS4", 0 );   // TCP3d-A
    GEL_MapAddStr( 0x021C8000, 0, 0x00000400, "R|W|AS4", 0 );   // TCP3d-B
    GEL_MapAddStr( 0x021D0000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-A
    GEL_MapAddStr( 0x021D4000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-B
    GEL_MapAddStr( 0x021D8000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-C
    GEL_MapAddStr( 0x021DC000, 0, 0x00000100, "R|W|AS4", 0 );   // VCP2-D
    GEL_MapAddStr( 0x021E0000, 0, 0x00001000, "R|W|AS4", 0 );   // TCP3e
    GEL_MapAddStr( 0x021F0000, 0, 0x00000800, "R|W|AS4", 0 );   // FFTC-A Configuration
    GEL_MapAddStr( 0x021F4000, 0, 0x00000800, "R|W|AS4", 0 );   // FFTC-B Configuration
    GEL_MapAddStr( 0x02200000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer0
    GEL_MapAddStr( 0x02210000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer1
    GEL_MapAddStr( 0x02220000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer2
    GEL_MapAddStr( 0x02230000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer3
    GEL_MapAddStr( 0x02240000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer4
    GEL_MapAddStr( 0x02250000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer5
    GEL_MapAddStr( 0x02260000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer6
    GEL_MapAddStr( 0x02270000, 0, 0x00000080, "R|W|AS4", 0 );   // Timer7
    GEL_MapAddStr( 0x02310000, 0, 0x00000200, "R|W|AS4", 0 );   // PLL Controller
    GEL_MapAddStr( 0x02320000, 0, 0x00000100, "R|W|AS4", 0 );   // GPIO
    GEL_MapAddStr( 0x02330000, 0, 0x00000400, "R|W|AS4", 0 );   // SmartReflex
    GEL_MapAddStr( 0x02350000, 0, 0x00001000, "R|W|AS4", 0 );   // Power Sleep Controller
    GEL_MapAddStr( 0x02360000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 0
    GEL_MapAddStr( 0x02368000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 1
    GEL_MapAddStr( 0x02370000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 2
    GEL_MapAddStr( 0x02378000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 3
    GEL_MapAddStr( 0x02380000, 0, 0x00000400, "R|W|AS4", 0 );   // Memory Protection Unit (MPU) 4
    GEL_MapAddStr( 0x02440000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 0
    GEL_MapAddStr( 0x02450000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 1
    GEL_MapAddStr( 0x02460000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 2
    GEL_MapAddStr( 0x02470000, 0, 0x00004000, "R|W|AS4", 0 );   // DSP Trace Formatter 3
    GEL_MapAddStr( 0x02530000, 0, 0x00000080, "R|W|AS4", 0 );   // I2C Data & Control
    GEL_MapAddStr( 0x02540000, 0, 0x00000040, "R|W|AS4", 0 );   // UART
    GEL_MapAddStr( 0x02600000, 0, 0x00002000, "R|W|AS4", 0 );   // Secondary Interrupt Controller (INTC) 0
    GEL_MapAddStr( 0x02604000, 0, 0x00002000, "R|W|AS4", 0 );   // Secondary Interrupt Controller (INTC) 1
    GEL_MapAddStr( 0x02608000, 0, 0x00002000, "R|W|AS4", 0 );   // Secondary Interrupt Controller (INTC) 2
    GEL_MapAddStr( 0x02620000, 0, 0x00000400, "R|W|AS4", 0 );   // Chip-Level Registers
    GEL_MapAddStr( 0x02640000, 0, 0x00000800, "R|W|AS4", 0 );   // Semaphore
    GEL_MapAddStr( 0x02700000, 0, 0x00008000, "R|W|AS4", 0 );   // EDMA Channel Controller (TPCC) 0
    GEL_MapAddStr( 0x02720000, 0, 0x00008000, "R|W|AS4", 0 );   // EDMA Channel Controller (TPCC) 1
    GEL_MapAddStr( 0x02740000, 0, 0x00008000, "R|W|AS4", 0 );   // EDMA Channel Controller (TPCC) 2
    GEL_MapAddStr( 0x02760000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC0 Transfer Controller (TPTC) 0
    GEL_MapAddStr( 0x02768000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC0 Transfer Controller (TPTC) 1
    GEL_MapAddStr( 0x02770000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 0
    GEL_MapAddStr( 0x02778000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 1
    GEL_MapAddStr( 0x02780000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 2
    GEL_MapAddStr( 0x02788000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC1 Transfer Controller (TPTC) 3
    GEL_MapAddStr( 0x02790000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 0
    GEL_MapAddStr( 0x02798000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 1
    GEL_MapAddStr( 0x027A0000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 2
    GEL_MapAddStr( 0x027A8000, 0, 0x00000400, "R|W|AS4", 0 );   // EDMA TPCC2 Transfer Controller (TPTC) 3
    GEL_MapAddStr( 0x027D0000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 0
    GEL_MapAddStr( 0x027E0000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 1
    GEL_MapAddStr( 0x027F0000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 2
    GEL_MapAddStr( 0x02800000, 0, 0x00004000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - Core 3
    GEL_MapAddStr( 0x02850000, 0, 0x00008000, "R|W|AS4", 0 );   // TI Embedded Trace Buffer (TETB) - System
    GEL_MapAddStr( 0x02900000, 0, 0x00008000, "R|W|AS4", 0 );   // Serial RapidIO Configuration
    GEL_MapAddStr( 0x02A00000, 0, 0x00100000, "R|W|AS4", 0 );   // Queue Manager Subsystem Configuration
    GEL_MapAddStr( 0x08000000, 0, 0x00010000, "R|W|AS4", 0 );   // Extended Memory Controller (XMC) Configuration
    GEL_MapAddStr( 0x0BC00000, 0, 0x00100000, "R|W|AS4", 0 );   // Multicore Shared Memory Controller (MSMC) Config
    GEL_MapAddStr( 0x0C000000, 0, 0x00200000, "R|W|AS4", 0 );   // Multicore Shared Memory (MSM)
    GEL_MapAddStr( 0x10800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core0 L2 SRAM
    GEL_MapAddStr( 0x10E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core0 L1P SRAM
    GEL_MapAddStr( 0x10F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core0 L1D SRAM
    GEL_MapAddStr( 0x11800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core1 L2 SRAM
    GEL_MapAddStr( 0x11E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core1 L1P SRAM
    GEL_MapAddStr( 0x11F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core1 L1D SRAM
    GEL_MapAddStr( 0x12800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core2 L2 SRAM
    GEL_MapAddStr( 0x12E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core2 L1P SRAM
    GEL_MapAddStr( 0x12F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core2 L1D SRAM
    GEL_MapAddStr( 0x13800000, 0, 0x00100000, "R|W|AS4", 0 );   // Core3 L2 SRAM
    GEL_MapAddStr( 0x13E00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core3 L1P SRAM
    GEL_MapAddStr( 0x13F00000, 0, 0x00008000, "R|W|AS4", 0 );   // Core3 L1D SRAM
    GEL_MapAddStr( 0x20000000, 0, 0x00100000, "R|W|AS4", 0 );   // System Trace Manager (STM) Configuration
    GEL_MapAddStr( 0x20200000, 0, 0x00400000, "R|W|AS4", 0 );   // RAC_B Data
    GEL_MapAddStr( 0x20600000, 0, 0x00100000, "R|W|AS4", 0 );   // TCP3d-B Data
    GEL_MapAddStr( 0x20800000, 0, 0x00100000, "R|W|AS4", 0 );   // TCP3d-A Data
    GEL_MapAddStr( 0x20900000, 0, 0x00002000, "R|W|AS4", 0 );   // TCP3e Data Write Port
    GEL_MapAddStr( 0x20902000, 0, 0x00002000, "R|W|AS4", 0 );   // TCP3e Data Read Port
    GEL_MapAddStr( 0x20B00000, 0, 0x00020000, "R|W|AS4", 0 );   // Boot ROM
    GEL_MapAddStr( 0x20BF0000, 0, 0x00000400, "R|W|AS4", 0 );   // SPI
    GEL_MapAddStr( 0x21000000, 0, 0x00000100, "R|W|AS4", 0 );   // DDR3 EMIF Configuration
    GEL_MapAddStr( 0x21400000, 0, 0x00000080, "R|W|AS4", 0 );   // Hyperlink Config (local)
    /*  Uncomment the following line to see the hyperlink remote config registers.
     *  Accessing the remote registers, even indirectly (by dragging a memory window 
     *  to be big enough to cover the remote registers) will result in a fatal error if
     *  hyperlink is powered on but the link has not been established.
     */
    //  GEL_MapAddStr( 0x21400080, 0, 0x00000080, "R|W|AS4", 0 );   // Hyperlink Config (remote)
    GEL_MapAddStr( 0x21800000, 0, 0x00008000, "R|W|AS4", 0 );   // PCIe Config
    GEL_MapAddStr( 0x22A00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_A
    GEL_MapAddStr( 0x22B00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_B
    GEL_MapAddStr( 0x22C00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_C
    GEL_MapAddStr( 0x22D00000, 0, 0x00010000, "R|W|AS4", 0 );   // VCP2_D
    GEL_MapAddStr( 0x33200000, 0, 0x00400000, "R|W|AS4", 0 );   // RAC_A Data
    GEL_MapAddStr( 0x34000000, 0, 0x00200000, "R|W|AS4", 0 );   // Queue Manager Subsystem Data
    GEL_MapAddStr( 0x34C00000, 0, 0x00030000, "R|W|AS4", 0 );   // TAC Data
    GEL_MapAddStr( 0x40000000, 0, 0x10000000, "R|W|AS4", 0 );   // Hyperlink Data
    GEL_MapAddStr( 0x50000000, 0, 0x10000000, "R|W|AS4", 0 );   // SRIO Data
    GEL_MapAddStr( 0x60000000, 0, 0x10000000, "R|W|AS4", 0 );   // PCIe Data
    GEL_MapAddStr( 0x80000000, 0, 0x80000000, "R|W|AS4", 0 );   // DDR3 EMIF Data

    GEL_TextOut( "Setup_Memory_Map... Done.\n" );
}

/****************************************************************************
 *
 * NAME
 *      Core_Info
 *
 * PURPOSE:
 *      Display on the screen information about the current running DSP core
 *
 * USAGE
 *
 *      Called from program or GEL menu
 *
 * RETURN VALUE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Core_Info( )
{
    GEL_TextOut("DSP core #%d\n",,1,,,DNUM);
}


/****************************************************************************
 *
 * NAME
 *      Wait_Soft
 *
 * PURPOSE:
 *      Wait for a specified delay in number of empty loop.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Wait_Soft(nloop)
 *
 *      nloop - (i) number of empty loop to do for delay
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Wait_Soft( int nloop )
{
    int i;

    // 1 sec ~ 40000 loop on P4 3.4GHz
    for( i = 0 ; i < nloop ; i++ )
    {
    }
}


/****************************************************************************
 *
 * NAME
 *      RoundToHigherInt
 *
 * PURPOSE:
 *      This routine will round a float value to higher int.
 *      ex.: RoundToHigherInt(7.1)=8, RoundToHigherInt(7.7)=8,
 *           RoundToHigherInt(7.0)=7
 *
 * USAGE
 *      This routine can be called as:
 *
 *      RoundToHigherInt(fValue)
 *
 *      fValue - (i) float value to be converted.
 *
 * RETURN VALUE
 *      Converted int value.
 *
 * REFERENCE
 *
 ****************************************************************************/
RoundToHigherInt(fValue)
{
    int iResult,iTemp;
    double fTemp, fSTolP, fSTolN, fPar, fZero;

    fSTolP =  1.0e-7;
    fSTolN = -1.0e-7;
    fPar = fValue;
    fZero = 0.0;

    // Compute a truncated value for fValue
    iTemp = fPar;

    // Convert int value to double floating point
    fTemp = iTemp;

    // Compute difference between truncated int and value to be converted
    fTemp = fPar - fTemp;

    // If value to be converted is positive
    if (fPar >= fZero)
    {
        // Verify equality by allowing single precision least digit tolerance 1e-7
        // to catch (int + fSTolP) like exact int value
        if ((fTemp >= fZero) && (fTemp < fSTolP))
            // Do not adjust int because wright on it
            iResult = iTemp;
        else
            // adjust to upper int
            iResult = iTemp + 1;
    }
    else
    {
        fTemp = 1 - fTemp;
        // Negative converted value
        // Verify equality by allowing single precision least digit tolerance 1e-7
        // to catch (int + fSTolP) like exact int value
        if (((fTemp >= fZero) && (fTemp < fSTolP)))
            // adjust to lower int cause we missed it
            iResult = iTemp - 1;
        else
            // Do not adjust int because wright on it
            iResult = iTemp;
    }

    //GEL_TextOut("ceil value:%f, int:%d\n",,,,,fValue, iResult);
    return(iResult);
}


/****************************************************************************
 *
 * NAME
 *      TimeToField
 *
 * PURPOSE:
 *      This routine will convert a ddr timing value in sec to a field integer
 *      value for the ddr timing registers.
 *      Does not validate register field overflow!
 *
 * USAGE
 *      This routine can be called as:
 *
 *      TimeToField(fValue, freq, position)
 *
 *      fValue   - (i) float timing value in sec (to be converted).
 *
 *      freq     - (i) ddr frequency value in Hz.
 *
 *      position - (i) position of field within register.
 *
 * RETURN VALUE
 *      Converted int ddr field value at correct position.
 *
 * REFERENCE
 *
 ****************************************************************************/
TimeToField(fValue, freq, position)
{
    int iResult;

    double fTemp;

    // Convert to double float
    fTemp = fValue;

    iResult = RoundToHigherInt((fTemp * freq)-1);
    iResult = iResult << position;

    return(iResult);
}


/****************************************************************************
 *
 * NAME
 *      ClckToField
 *
 * PURPOSE:
 *      This routine will convert a ddr timing value in clock period unit to
 *      a field integer value for the ddr timing registers.
 *      Does not validate register field overflow!
 *
 * USAGE
 *      This routine can be called as:
 *
 *      ClckToField(value, position)
 *
 *      value    - (i) timing value in clock unit (to be converted).
 *
 *      position - (i) position of field within register.
 *
 * RETURN VALUE
 *      Converted int ddr field value at correct position.
 *
 * REFERENCE
 *
 ****************************************************************************/
ClckToField(value, position)
{
    int iResult;

    iResult = (value - 1) << position;

    return(iResult);
}




/****************************************************************************
 *
 * NAME
 *      Init_Pll2 (unsigned int multiplier, unsigned int divider)
 *
 * PURPOSE:
 *      Setup PLL 2 frequency for DDR3 clock.
 *      The Frequency is based on an external ddr3 clk input ref of 66.65 MHz clock.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Init_Pll2( unsigned int multiplier, unsigned int divider)
 *
 *      multiplier - (i) Multiplier
 *      divider    - (i) Divider
 *      Note that the values above are actual register values, i.e., 
 *      the computed values - 1
 * RETURN VALUE
 *      None 
 *
 * REFERENCE
 *
 ****************************************************************************/
Init_Pll2(unsigned int multiplier, unsigned int divider)
{
    unsigned int temp, i;

    GEL_TextOut ( "DDR3 PLL (PLL2) Setup ... \n");
    /*Unlock Boot Config*/
    KICK0 = 0x83E70B13;
    KICK1 = 0x95A4F1E0;

    if (DNUM == 0)
    {
        /* Usage Note 9: For optimal PLL operation, the ENSAT bit in the PLL control *
         * registers for the Main PLL, DDR3 PLL, and PA PLL should be set to 1.      *
         * The PLL initialization sequence in the boot ROM sets this bit to 0 and    *
         * could lead to non-optimal PLL operation. Software can set the bit to the  *
         * optimal value of 1 after boot                                             *
         * DDR3PLLCTL1 Bit map                                                         *
         * |31...7   |6     |5 4       |3...0      |                                 *
         * |Reserved |ENSAT |Reserved  |BWADJ[11:8]|                                 */
        DDR3PLLCTL1 |= 0x00000040;

        /* Put the PLL in PLL Mode                                                   *
         * DDR3PLLCTL0 Bit map                                                         *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
        DDR3PLLCTL0 |= 0x00800000; /* Set the Bit 23 */

        /* Wait for the PLL Reset time (min: 5 us)                                */
        //Delay_milli_seconds(1);

        /* In PLL Controller, reset the PLL (bit 13 in DDR3PLLCTL1 register)         */
        DDR3PLLCTL1 |= 0x00002000;

        /* Program the necessary multipliers/dividers and BW adjustments             */
        /* Set the divider values */
        DDR3PLLCTL0 &= ~(0x0000003F);
        DDR3PLLCTL0 |= (divider & 0x0000003F);

        /* Set the Multipler values */
        DDR3PLLCTL0 &= ~(0x0007FFC0);
        DDR3PLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );

        /* Set the BWADJ */
        temp = ((multiplier + 1) >> 1) - 1;
        DDR3PLLCTL0 &= ~(0xFF000000); 
        DDR3PLLCTL0 |= ((temp << 24) & 0xFF000000);
        DDR3PLLCTL1 &= ~(0x0000000F);
        DDR3PLLCTL1 |= ((temp >> 8) & 0x0000000F);

        /* Wait for the PLL Reset time (min: 5 us)                                */
        Delay_milli_seconds(1);

        /*In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset */
        DDR3PLLCTL1 &= ~(0x00002000);

        /* Wait at least 500 * REFCLK cycles * PLLD (this is the PLL lock time) */
        Delay_milli_seconds(1);

        /* Put the PLL in PLL Mode                                                   *
         * DDR3PLLCTL0 Bit map                                                         *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
        DDR3PLLCTL0 &= ~(0x00800000); /* ReSet the Bit 23 */

        GEL_TextOut( "DDR3 PLL Setup... Done.\n" );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set DDR3 PLL\n",,2,,,DNUM);
    }
}

/****************************************************************************
 *
 * NAME
 *      Init_Pll3
 *
 * PURPOSE:
 *      Setup PLL 3 frequency for DSP PASS clock.
 *      The Frequency is based on an external pass clk input ref of 122.88 MHz clock.
 *
 * USAGE
 *      Init_Pll3( unsigned int multiplier, unsigned int divider)
 *
 *      multiplier - (i) Multiplier
 *      divider    - (i) Divider
 *      Note that the values above are actual register values, i.e., 
 *      the computed values - 1
 *
 * REFERENCE
 *
 ****************************************************************************/
Init_Pll3(unsigned int multiplier, unsigned int divider)
{
    unsigned int temp, i;

    GEL_TextOut ( "PA PLL (PLL3) Setup ... \n");
    /*Unlock Boot Config*/
    KICK0 = 0x83E70B13;
    KICK1 = 0x95A4F1E0;

    if (DNUM == 0)
    {
        /* Usage Note 9: For optimal PLL operation, the ENSAT bit in the PLL control *
         * registers for the Main PLL, PA PLL, and PA PLL should be set to 1.      *
         * The PLL initialization sequence in the boot ROM sets this bit to 0 and    *
         * could lead to non-optimal PLL operation. Software can set the bit to the  *
         * optimal value of 1 after boot                                             *
         * PAPLLCTL1 Bit map                                                         *
         * |31...7   |6     |5 4       |3...0      |                                 *
         * |Reserved |ENSAT |Reserved  |BWADJ[11:8]|                                 */
        PAPLLCTL1 |= 0x00000040;

        /* Put the PLL in PLL Mode                                                   *
         * PAPLLCTL0 Bit map                                                         *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
        PAPLLCTL0 |= 0x00800000; /* Set the Bit 23 */

        /* Wait for the PLL Reset time (min: 5 us)                                */
        //Delay_milli_seconds(1);

        /* In PLL Controller, reset the PLL (bit 14), set PLLSEL (bit 13)  in PAPLLCTL1 register)         */
        PAPLLCTL1 |= 0x00006000;

        /* Program the necessary multipliers/dividers and BW adjustments             */
        /* Set the divider values */
        PAPLLCTL0 &= ~(0x0000003F);
        PAPLLCTL0 |= (divider & 0x0000003F);

        /* Set the Multipler values */
        PAPLLCTL0 &= ~(0x0007FFC0);
        PAPLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );

        /* Set the BWADJ */
        temp = ((multiplier + 1) >> 1) - 1;
        PAPLLCTL0 &= ~(0xFF000000); 
        PAPLLCTL0 |= ((temp << 24) & 0xFF000000);
        PAPLLCTL1 &= ~(0x0000000F);
        PAPLLCTL1 |= ((temp >> 8) & 0x0000000F);

        /* Wait for the PLL Reset time (min: 5 us)                                */
        Delay_milli_seconds(1);

        /*In PAPLLCTL1, write PLLRST = 0 to bring PLL out of reset */
        PAPLLCTL1 &= ~(0x00004000);

        /* Wait at least 500 * REFCLK cycles * PLLD (this is the PLL lock time) */
        Delay_milli_seconds(1);

        /* Put the PLL in PLL Mode                                                   *
         * PAPLLCTL0 Bit map                                                         *
         * |31...24    |23     |22...19       |18...6   |5...0 |                     *
         * |BWADJ[7:0] |BYPASS |Reserved      |PLLM     |PLLD  |                     */
        PAPLLCTL0 &= ~(0x00800000); /* ReSet the Bit 23 */

        GEL_TextOut( "PA PLL Setup... Done.\n" );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set PA PLL\n",,2,,,DNUM);
    }

}

/****************************************************************************
 *
 * NAME
 *      Set_Pll3_1044_MHz
 *
 * PURPOSE:
 *      Setup PLL 3 pass clk @ 1044 MHz from External input ref clock
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Pll3_1044_MHz()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Pll3_1044_MHz( )
{
    unsigned int PLLM_PASS = 31;
    unsigned int PLLD_PASS = 1;

    Init_Pll3(PLLM_PASS, PLLD_PASS);
}

/****************************************************************************
 *
 * NAME
 *      Set_Pin_Board
 *
 * PURPOSE:
 *      Configure DSP IO pin (and timers pins) and board for normal operation
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Pin_Board()
 *
 * RETURN VALUE
 *      =1 SUCCESS, =0 FAIL
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Pin_Board( )
{
    int iResult=1,iData;

    // Only core0 can set GPIO
    if (DNUM == 0)
    {
        GEL_TextOut( "Set Board and DSP IO/Timers Pins... \n" );

        // Unlock Boot Config
        KICK0 = 0x83E70B13;
        KICK1 = 0x95A4F1E0;

        // Configure DSP GP IO related to board functions
        GPIO_BITEN=0;                           // Disable GPIO irq
        GPIO_OUT_DATA=GPIO_DEFAULT_OUT;         // Set pins correct out values
        GPIO_DIR=GPIO_DEFAULT_DIR;              // Configure io directions for EVM

        //Setup timer manager for external pin routing
        // Timer1 lo from external TIMI1, others from TIMI0 (Timer inputs))
        TINPSEL = 0x0000000C;

        // Timer1 lo to external TIMO1, Timer0 lo to external TIMO0 (Timer Outputs)
        TOUTPSEL = 0x00000040;

        // Lock Boot Config
        KICK0 = 0;
        KICK1 = 0;

        // Checks if we got an error
        if (iResult)
            GEL_TextOut( "Set Board and DSP IO/Timers Pins... Done.\n" );
        else
            GEL_TextOut( "Set Board and DSP IO/Timers Pins... ERROR!\n",,2,, );
    }
    else
    {
        GEL_TextOut("DSP core #%d cannot set IO/Timers.\n",,2,,,DNUM);
    }
    return(iResult);
}


/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup_Silent
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup_Silent()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Global_Default_Setup_Silent()
{
    float gel_ver = GEL_VERSION;
    int count;

    /* DDR PLL settings for 1333 MHz */
    unsigned int PLLM_DDR = 19;
    unsigned int PLLD_DDR = 0;

    /* PASS PLL settings for 1044 MHz */
    unsigned int PLLM_PASS = 31;
    unsigned int PLLD_PASS = 1;

    // Set DSP cache to pre defined values...
    GEL_TextOut( "C6670L GEL file Ver is %f \n",,,,, (float) (gel_ver/1.0));

    Set_DSP_Cache();

    // Only core 0 can set these
    if (DNUM == 0)
    {
        for (count = 0; count < PLL_REINIT_MAX_COUNT; count++) {

            // Setup main Pll DSP @ 983 MHz
            Init_PLL(PLL1_M, PLL1_D);

            // Setup all Power Domains on
            Set_Psc_All_On( );

            // Setup Pll3 pass clk @ 1044 MHz
            Init_Pll3(PLLM_PASS, PLLD_PASS);

            // Setup Pll2 DDR3 PLL @ 667 MHz
            Init_Pll2(PLLM_DDR, PLLD_DDR);

            GEL_TextOut( "DDR begin (1333 auto)\n");
            xmc_setup();
            ddr3_setup_auto_lvl_1333(0);
            GEL_TextOut( "DDR done\n");

            if(ddr3_memory_test() == 0) {
                break;
            }

        }

        if (count == PLL_REINIT_MAX_COUNT) {
            GEL_TextOut( "PLL and DDR Initialization failed ...\n");
        } else {
            GEL_TextOut( "PLL and DDR Initialization completed(%d) ...\n",,,,, count);
        }

        // Configure SGMII SERDES
        configSGMIISerdes();

        // Setup DSP IO Pins (and timers pins) and EVM board settings
        Set_Pin_Board( );

        GEL_TextOut( "Configuring CPSW ...\n");
        setCpSwConfig();   
        GEL_TextOut( "Configuring CPSW ...Done \n");    

    }
}


